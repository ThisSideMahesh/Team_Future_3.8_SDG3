/**
 * SwasthyaSetu - Firestore Security Rules
 *
 * Core Philosophy:
 * This ruleset enforces a strict, patient-centric security model where consent is paramount.
 * The default posture is "deny all," with access granted explicitly based on user roles and
 * data ownership. Patients have ultimate control over their personal data and consent settings.
 * Doctors can only access patient data when permitted, and all such access is logged for auditing.
 *
 * Data Structure:
 * The data is organized into top-level collections for primary entities: `patients`, `doctors`,
 * `healthRecords`, `accessLogs`, and `labReports`. This segregation allows for distinct and granular
 * security rules per entity. Patient-specific data that they directly control, such as consent,
 * is stored in a subcollection (`/patients/{patientId}/consents`) to leverage path-based
 * security for clear ownership.
 *
 * Key Security Decisions:
 * - Default Deny: All operations are denied unless an `allow` rule explicitly permits them.
 * - Strict Ownership: Users (patients and doctors) can only access and manage their own
 *   profile documents (`/patients/{userId}` or `/doctors/{userId}`).
 * - No Public Listing: To prevent data scraping and protect user privacy, listing documents
 *   in top-level collections like `patients` and `doctors` is disabled.
 * - Immutable Logs: The `accessLogs` collection is append-only. Once a log is created,
 *   it cannot be modified or deleted, ensuring a secure audit trail.
 * - Backend-Managed Records: Health records are considered sensitive and are managed exclusively
 *   by trusted backend services (Cloud Functions). Direct client writes are disabled. Patients
 *   are granted read-only access to their own records.
 *
 * Denormalization for Authorization:
 * To ensure fast and secure authorization checks, this ruleset relies on denormalized data.
 * - `healthRecords` documents contain a `patientId` field, allowing rules to verify patient
 *   ownership without performing extra reads.
 * - `accessLogs` documents contain both a `patientId` and a `doctorId`, allowing both parties
 *   to view a relevant log entry and enabling rules to verify the creator of the log.
 * This approach avoids slow and costly `get()` calls within rule evaluations.
 *
 * Structural Segregation:
 * The design uses separate collections for different data types (e.g., `patients`, `healthRecords`,
 * `accessLogs`) instead of a single collection with role-based flags. This provides stronger
 * security boundaries, simplifies rules, and makes list operations inherently safer, as each
 * collection can have its own specific listing permissions.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for verifying document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user is a doctor by verifying their profile document.
     */
    function isDoctor() {
      return isSignedIn() && exists(/databases/$(database)/documents/doctors/$(request.auth.uid));
    }

    /**
     * Checks if a patient has granted consent for data aggregation.
     * Assumes the consent document ID is the same as the patient's UID for predictability.
     */
    function hasConsent(patientId) {
      // Check if a consent document for this patient exists and its 'granted' field is true.
      // We assume the consent document ID is the same as the patientId for predictability.
      return exists(/databases/$(database)/documents/patients/$(patientId)/consents/$(patientId))
             && get(/databases/$(database)/documents/patients/$(patientId)/consents/$(patientId)).data.granted == true;
    }

    /**
     * Checks if a document currently exists.
     * Used in update/delete rules to prevent acting on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Validates that the incoming document's ID matches the user's ID on creation.
     * Enforces relational integrity between the auth UID and the document content.
     */
    function hasValidPatientIdOnCreate(patientId) {
      return request.resource.data.id == patientId;
    }
    
    /**
     * Validates that the incoming document's ID matches the user's ID on creation.
     * Enforces relational integrity between the auth UID and the document content.
     */
    function hasValidDoctorIdOnCreate(doctorId) {
      return request.resource.data.id == doctorId;
    }

    /**
     * Ensures the document's ID field is immutable on update.
     * Prevents re-assigning a document from one user to another.
     */
    function isIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }


    /**
     * @description Rules for patient profile documents.
     * @path /patients/{patientId}
     * @allow (get) A patient can read their own profile. A doctor can read a patient's profile if consent is granted.
     * @allow (create) A new patient can create their own profile document. `auth.uid == patientId`
     * @deny (list) No user can list all patients in the system.
     * @deny (get) A patient cannot read another patient's profile. `auth.uid != patientId`
     * @principle Restricts access to a user's own data tree, but allows consented access for doctors.
     */
    match /patients/{patientId} {
      allow get: if isOwner(patientId) || (isDoctor() && hasConsent(patientId));
      allow list: if false;
      allow create: if isOwner(patientId) && hasValidPatientIdOnCreate(patientId);
      allow update: if isOwner(patientId) && isExistingDoc() && isIdImmutable();
      allow delete: if isOwner(patientId) && isExistingDoc();

      /**
       * @description Rules for a patient's consent documents.
       * @path /patients/{patientId}/consents/{consentId}
       * @allow (list) A patient can list their own consent documents. `auth.uid == patientId`
       * @allow (update) A patient can update their own consent status. `auth.uid == patientId`
       * @deny (create) A doctor cannot create a consent document for a patient.
       * @deny (update) A patient cannot modify another patient's consent. `auth.uid != patientId`
       * @principle Enforces strict document ownership within a user's data tree.
       */
      match /consents/{consentId} {
        allow get: if isOwner(patientId);
        allow list: if isOwner(patientId);
        allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
        allow update: if isOwner(patientId) && isExistingDoc() && request.resource.data.patientId == resource.data.patientId;
        allow delete: if isOwner(patientId) && isExistingDoc();
      }
    }

    /**
     * @description Rules for doctor profile documents.
     * @path /doctors/{doctorId}
     * @allow (get) A doctor can read their own profile. `auth.uid == doctorId`
     * @allow (create) A new doctor can create their own profile document. `auth.uid == doctorId`
     * @deny (list) No user can list all doctors in the system.
     * @deny (get) A doctor cannot read another doctor's profile. `auth.uid != doctorId`
     * @principle Restricts access to a user's own data tree.
     */
    match /doctors/{doctorId} {
      allow get: if isOwner(doctorId);
      allow list: if false;
      allow create: if isOwner(doctorId) && hasValidDoctorIdOnCreate(doctorId);
      allow update: if isOwner(doctorId) && isExistingDoc() && isIdImmutable();
      allow delete: if isOwner(doctorId) && isExistingDoc();
    }

    /**
     * @description Rules for aggregated patient health records. This path contains a subcollection of actual records.
     * @path /healthRecords/{healthRecordId}
     * @allow (none) Direct access to the parent document is generally not needed.
     * @deny (list, create, update, delete) Direct client modification is forbidden.
     * @principle Protects sensitive data by making it read-only for the owner and consented doctors, and write-locked for clients.
     */
    match /healthRecords/{healthRecordId} {
      // This document itself is not meant to be read directly. Rules are for the subcollection.
      allow read, write: if false;

      /**
       * @description Rules for the individual medical events within a health record.
       * @path /healthRecords/{healthRecordId}/records/{recordId}
       * @allow (get, list) A patient can read their own history. A doctor can read with consent.
       * @deny (create, update, delete) All writes must go through a trusted backend.
       */
      match /records/{recordId} {
        // healthRecordId is the same as the patientId
        allow get, list: if isOwner(healthRecordId) || (isDoctor() && hasConsent(healthRecordId));
        allow write: if false;
      }
    }

    /**
     * @description Rules for the audit log of data access events.
     * @path /accessLogs/{accessLogId}
     * @allow (get) A patient or doctor can read a log entry they are part of.
     * @allow (create) A doctor can create a log entry for an action they perform.
     * @deny (list) Listing all access logs is forbidden to prevent data mining.
     * @deny (update, delete) Log entries are immutable and cannot be changed or deleted.
     * @principle Enforces an immutable, append-only audit trail.
     */
    match /accessLogs/{accessLogId} {
      allow get: if isOwner(resource.data.patientId) || isOwner(resource.data.doctorId);
      allow list: if false;
      allow create: if isOwner(request.resource.data.doctorId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rules for lab reports.
     * @path /labReports/{labReportId}
     * @allow (none) All access is denied by default until a proper ownership model is defined.
     * @deny (all) Direct client access is forbidden as there is no ownership field in the schema.
     * @principle Enforces a secure-by-default posture for data with an undefined access pattern.
     */
    match /labReports/{labReportId} {
      // CRITICAL: Cannot implement owner-only writes. The 'LabReport' entity is missing an 'ownerId' or 'patientId' field.
      // Access must be brokered by a trusted backend (e.g., Cloud Function) until the schema is updated.
      allow read, write: if false;
    }
  }
}
